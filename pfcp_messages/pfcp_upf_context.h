/*
 * Copyright (c) 2019 Sprint
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef PFCP_UPF_CONTEXT_H
#define PFCP_UPF_CONTEXT_H

#include "ue.h"
#include "cp.h"
#include "gtp_ies.h"
#include "gtpv2c_set_ie.h"
#include "gtp_messages.h"
#include "../ipc/dp_ipc_api.h"
#include "restoration_timer.h"

typedef enum pfcp_assoc_status_en {
	ASSOC_IN_PROGRESS = 0,
	ASSOC_ESTABLISHED = 1,
} pfcp_assoc_status_en;


/* Need to use this for upf_context */
extern uint32_t	*g_gx_pending_csr[BUFFERED_ENTRIES_DEFAULT];
extern uint32_t	g_gx_pending_csr_cnt;

/**
 * @brief  : Maintains the Context for Gx interface
 */
typedef struct gx_context_t {
	uint8_t state;
	uint8_t proc;
	char gx_sess_id[MAX_LEN];
	unsigned long  rqst_ptr; /*In Case of RAA, need to store RAR pointer*/
} gx_context_t;

/**
 * @brief  : Maintains context of upf
 */
typedef struct upf_context_t {
	pfcp_assoc_status_en	assoc_status;

	uint32_t	csr_cnt;
	uint32_t	*pending_csr[BUFFERED_ENTRIES_DEFAULT];
	uint32_t	*pending_csr_teid[BUFFERED_ENTRIES_DEFAULT];
	char	fqdn[MAX_HOSTNAME_LENGTH];

	uint16_t up_supp_features;
	uint8_t  cp_supp_features;
	uint32_t s1u_ip;
	uint32_t s5s8_sgwu_ip;
	uint32_t s5s8_pgwu_ip;
	uint8_t  state;
	/* Add timer_entry for pfcp assoc req */
	peerData *timer_entry;
	create_sess_req_t csr;
} upf_context_t;

/**
 * @brief  : Maintains results returnd via dns for upf
 */
typedef struct upfs_dnsres_t {
	uint8_t upf_count;
	uint8_t current_upf;
	struct in_addr upf_ip[UPF_ENTRIES_DEFAULT];
	char upf_fqdn[UPF_ENTRIES_DEFAULT][MAX_HOSTNAME_LENGTH];
} upfs_dnsres_t;

#pragma pack()

/* upflist returned via DNS query */
struct rte_hash *upflist_by_ue_hash;

struct rte_hash *upf_context_by_ip_hash;

struct rte_hash *gx_context_by_sess_id_hash;

/**
 * @brief  : Process create session request, update ue context, bearer info
 * @param  : csr, holds information in csr
 * @param  : context, ue context structure pointer
 * @param  : upf_ipv4, upf ip
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
process_create_sess_req(create_sess_req_t *csr,
					ue_context **context, struct in_addr *upf_ipv4);

/**
 * @brief  : Process pfcp session association request
 * @param  : context, ue context structure pointer
 * @param  : ebi_index, index of ebi in array
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
process_pfcp_assoication_request(pdn_connection *pdn, uint8_t ebi_index);


/* TODO: Remove first param when autogenerated code for GTPV2-c
 * is integrated.
 */
/**
 * @brief  : Process pfcp session establishment request
 * @param  : teid
 * @param  : ebi_index, index of ebi in array
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
process_pfcp_sess_est_request(uint32_t teid, pdn_connection *pdn,  upf_context_t *upf_ctx);

/**
 * @brief  : Process pfcp session modification request
 * @param  : mbr, holds information in session modification request
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
process_pfcp_sess_mod_request(mod_bearer_req_t *mbr);

/**
 * @brief  : Process pfcp session modification request for handover scenario
 * @param  : mbr, holds information in session modification request
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
process_pfcp_sess_mod_req_handover(mod_bearer_req_t *mbr);

/**
 * @brief  : Process pfcp session modification request for handover scenario
 * @param  : mbr, holds information in session modification request
 * @return : Returns 0 in case of success , -1 otherwise
 */

int
send_pfcp_sess_mod_req_handover(pdn_connection *pdn, eps_bearer *bearer,
			mod_bearer_req_t *mbr);

/**
 * @brief  : Process pfcp session deletion request
 * @param  : ds_req, holds information in session deletion request
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
process_pfcp_sess_del_request(del_sess_req_t *ds_req);

/**
 * @brief  : Process delete session request on sgwc
 * @param  : ds_req, holds information in session deletion request
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
process_pfcp_sess_del_request_delete_bearer_rsp(del_bearer_rsp_t *db_rsp);

int
process_sgwc_delete_session_request(del_sess_req_t *ds_req);

/**
 * @brief  : Set values in pdn type ie
 * @param  : pdn , pdn type ie structure pointer to be filled
 * @param  : pdn_mme, use values from this structure to fill
 * @return : Returns nothing
 */
void
set_pdn_type(pfcp_pdn_type_ie_t *pdn, pdn_type_ie *pdn_mme);

/**
 * @brief  : Creates upf context hash
 * @param  : No param
 * @return : Returns nothing
 */
void
create_upf_context_hash(void);

/**
 * @brief  : Creates gx conetxt hash
 * @param  : No param
 * @return : Returns nothing
 */
void
create_gx_context_hash(void);

/**
 * @brief  : Creates upf hash using ue
 * @param  : No param
 * @return : Returns nothing
 */
void
create_upf_by_ue_hash(void);

/**
 * @brief  : Processes pfcp session report request
 * @param  : pfcp_sess_rep_req, holds information in pfcp session report request
 * @return : Returns 0 in case of success , -1 otherwise
 */
uint8_t
process_pfcp_report_req(pfcp_sess_rpt_req_t *pfcp_sess_rep_req);

/**
 * @brief  : Set values in pfd contents ie
 * @param  : pfd_conts, ie structure to be filled
 * @param  : cstm_buf, data to be filled
 * @return : Returns 0 in case of success , -1 otherwise
 */
uint16_t
set_pfd_contents(pfcp_pfd_contents_ie_t *pfd_conts, struct msgbuf *cstm_buf);

/**
 * @brief  : Fill pfcp pfd management request
 * @param  : pfcp_pfd_req, pointer to structure to be filled
 * @param  : len, Total len
 * @return : Returns nothing
 */
void
fill_pfcp_pfd_mgmt_req(pfcp_pfd_mgmt_req_t *pfcp_pfd_req, uint16_t len);

/**
 * @brief  : Process pfcp pfd management request
 * @param  : No param
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
process_pfcp_pfd_mgmt_request(void);

/**
 * @brief  : Add entry to upflist hash
 * @param  : imsi_val, imsi value
 * @param  : imsi_len, imsi length
 * @param  : entry, entry to be added in hash
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
upflist_by_ue_hash_entry_add(uint64_t *imsi_val, uint16_t imsi_len,
		upfs_dnsres_t *entry);

/**
 * @brief  : search entry in upflist hash
 * @param  : imsi_val, imsi value
 * @param  : imsi_len, imsi length
 * @param  : entry, entry to be filled with search result
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
upflist_by_ue_hash_entry_lookup(uint64_t *imsi_val, uint16_t imsi_len,
		upfs_dnsres_t **entry);

/**
 * @brief  : delete entry in upflist hash
 * @param  : imsi_val, imsi value
 * @param  : imsi_len, imsi length
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
upflist_by_ue_hash_entry_delete(uint64_t *imsi_val, uint16_t imsi_len);

/**
 * @brief  : Add entry to upf conetxt hash
 * @param  : upf_ip, up ip address
 * @param  : entry ,entry to be added
 * @return : Returns 0 in case of success , -1 otherwise
 */
uint8_t
upf_context_entry_add(uint32_t *upf_ip, upf_context_t *entry);

/**
 * @brief  : search entry in upf hash using ip
 * @param  : upf_ip, key to search entry
 * @param  : entry, variable to store search result
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
upf_context_entry_lookup(uint32_t upf_ip, upf_context_t **entry);

/**
 * @brief  : Add entry into gx context hash
 * @param  : sess_id , key to add entry
 * @param  : entry , entry to be added
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
gx_context_entry_add(char *sess_id, gx_context_t *entry);

/**
 * @brief  : search entry in gx context hash
 * @param  : sess_id , key to add entry
 * @param  : entry , entry to be added
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
gx_context_entry_lookup(char *sess_id, gx_context_t **entry);

/**
 * @brief  : Create s5s8 hash table in sgwc
 * @param  : No param
 * @return : Returns nothing
 */
void
create_s5s8_sgwc_hash_table(void);

/**
 * @brief  : Remove s5s8 hash table in sgwc
 * @param  : No param
 * @return : Returns nothing
 */
void
clear_s5s8_sgwc_hash_table(void);

/**
 * @brief  : Generate and Send CCRU message
 * @param  : Modify Bearer Request
 * @return : Returns 0 in case of success , -1 otherwise
 */
int
send_ccr_u_msg(mod_bearer_req_t *mb_req);

#endif 
